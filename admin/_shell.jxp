<%
JSON = core.content.json();
var shellId = request.id;
if ( ! shellId ){
    print( "no shellId :(" );
    return;
}

var isShellCommand = function(cmd) {
	return (new admin.data.Bash()).getCmdArray().contains(cmd);
}

var gg = scope.globals.getParent();
var holder = gg._adminScopeHolder;
if ( ! holder ){
    holder = {};
    var s = gg.getTLPreferred();
    gg.setTLPreferred( gg );
    gg._adminScopeHolder = holder;
    gg.setTLPreferred( s );
}


var theScope = holder[ shellId ];
var populate = function(theScope){
    // FIXME: run the stored session commands here to populate the scope??
    // Load the scope from the DB?? Not sure..

    theScope.clearCommandHistory = function(){
        db.shell.sessions.remove({user: user});
        print.termCommand("reload");
    };

    theScope.clearScope = function(){
        for(var key in theScope){
            delete theScope[key];
        }
    };

    theScope.clearTranscript = function(){
        print.termCommand("clear");
        return "";
    };

    theScope.clearAll = function(){
        theScope.clearScope();
        theScope.clearTranscript();
    };

    theScope.setPrompt = function(prompt){
        print.termCommand("setprompt", {$prompt: prompt});
        user.shell = user.shell || {};
        user.shell.prompt = prompt;
        db.users.save(user);
    };

    theScope.sh = new admin.data.Bash();
    theScope.shoutput = function(cmd){
        print(cmd.out + (cmd.out && cmd.err? '\\n': '') + cmd.err);
    };
}

if ( ! theScope ){
    log("Creating scope for " + shellId);
    parent = gg.child( "_shell scope parent : " + shellId );
    populate(parent);
    theScope = parent.child( "_shell scope : " + shellId );
    theScope.setGlobal( true );
    holder[ shellId ] = theScope;
}

theScope.setGlobal( true );
var res = null;
var exc = null;
var oldprint = print;

var Buffer = function(){
    var _buffer = [];
    return Object.extend(function(s){
        if(_buffer.length == 0 || _buffer[_buffer.length-1].$command)
            _buffer.push(s.toString());
        else
            _buffer[_buffer.length-1] += s;

    }, {
        termCommand: function(command, args){
            // args is an Object
            args = args || {};
            _buffer.push(Object.extend(args, {$command: command}));
        },
        getBuffer: function(){
            return _buffer;
        }
    });
};

var command = request.command;
if(request.mode == "bash"){
    for(var i = 0; i < command.length; ++i){
        if(command[i] == ' ' || command[i] == '(')
            break;
    }
    
    var cmdverb = command.substring(0,i);

    if (!isShellCommand(cmdverb)) {
        command = "print(\"" + cmdverb + " : Command not found. For more info, try 'help'\")";
    }
    else {
	    
	    if(i >= command.length){
	        command = command + "()";
	    }
	    else {
	        if(command[i] == '(') // OK, the user put parens in here, whee
	            ;
	        if(command[i] == ' ') {
	            var args = command.substring(i+1);
	            args = tojson(args.split(/\s+/));
	            command = command.substring(0, i) + '(' + args + ')';
	        }
	    }
	
	    command = "shoutput(sh."+command+");";
	    log.debug("processing command " + command);
	}
}

var buffer = Buffer();
print = buffer;
try {
    res = theScope.eval( command , "aaaa" + shellId , null );
}
catch (e){
    var ary = [e.toString()];
    var st = e.getStackTrace();
    for(var i = 0; i < st.length; i++){
        ary.push(st[i]);
        if(st[i].toString().match(/__shell/)) break;
    }
    exc = ary.join("<br/>");
}
finally{
    print = oldprint;
}

var garbage = tojson(res);
if(! JSON.check(garbage)){
    // res doesn't tojson into actual JSON
    buffer.termCommand("warn", {$message: "Returned object did not convert to valid JSON. Returning wrapped object."});
    res = {"not_json" : garbage};
}

var res = { $ : res, $printed : buffer.getBuffer(), $exception : exc,
        $scope: Object.extend({}, theScope), $pwd: theScope.sh.pwd().out.trim()};
print( tojson( res ) );

if(request.save == "true"){
    // Only the client knows whether to save this command.
    var session = db.shell.sessions.findOne({user: user});
    if(session == null) 
        // Is this an error? or is it because the session was just removed?
        return;
    if(session.user == null)
        // DBRef breakage; the user isn't really on this site?
        return;
// Originally we intended to serialize the history so we could show the user
// what they were doing and the last few lines of command-response,
// but that isn't too helpful since there's lots of history and tojson'ing
    // it is pretty slow. Plus, we sometimes get buffer overflows.
//    session.push(request.mode, request.command, tojson(res));

    session.push(request.mode, request.command, "");
    db.shell.sessions.save(session);
}
%>
